I'm thinking it would be cool to write a factoid language debugger for marlen. Probably what would happen is there would be a command or a function (probably a function since I'm trying to move everything except for ~factoid and ~help into functions, and if it's a function a bot could potentially be programmed to automatically load the debugger on startup) that allows for the debugger to be started on a particular port, most likely restricted to the ones that starthttp can start servers on. Right now, only one debugger can be started at a time, and only one connection to the debugger can be present at any given time. If another connection is established, and the user provides a correct key when connecting, then the first connection will most likely be disconnected.

Since factoids are programmed by chatting with the server, not by using some sort of IDE that the debugger might have access to, the bot will need to send the contents of all factoids that are to be debugged to the client. This will probably happen when either a breakpoint is encountered, or the user steps into another factoid from one that they are currently debugging.

Factoids in the debugger are read-only, IE you can't edit the factoid text and "live-update" it. This has one advantage, which is that adding a breakpoint can be accomplished simply by double-clicking on a character, and the closest surrounding factoid entity to that character will be marked as a breakpoint (and probably highlighted with some special textual marking).

The bot should also send variables to the client, so that the client can open some windows and see the values of variables. Global variable and persistent variables should be visible even when a factoid is not actively being debugged, as long as a connection to the bot is present. The bot will push new variable values to the debugger interface as they are made available. It will, however, push these by way of a queue, so as not to freeze up the bot if the debugger connection has been lost but the bot hasn't yet realized it.

Local variables and chain variables can only be viewed when debugging a particular factoid. Since they are "thread-specific", they can probably be sent to the client along with a "frame" of debugging information when the client steps into, steps out of, or steps over something in the current factoid.

Actually writing debugger support into the interpreter will probably be a bit of a challenge. One thing that needs to be thought over is the fact that the TimedKillThread monitoring the factoid execution thread needs to be suspended in some manner, or perhaps even removed altogether. The debugger interface should probably provide a mechanism for listing all currently-running factoids (which could be obtained by searching for all threads that have an invocation of FactEntity.resolve() on their stack), and a mechanism for injecting a timed kill thread exception into those. This would allow the timed kill thread for a factoid that's to be debugged to be destroyed without freezing the bot if the factoid ends up going longer than it should, since the user could then use the debugger interface to kill the factoid. 

It would also be nice if the debugger could maintain an active list of all factoids that are running, along with the ability to pause any currently-running factoid. One thing that might help to facilitate this is if running a factoid adds that java thread to some sort of state-tracking map, and exiting out of the factoid removes the java thread from the state-tracking map. This would probably call for a new FactEntity, maybe called TopLevelEntity or something, which serves simply to delegate to another entity but add stuff to the state-tracking map first. This entity should also check to see if the current thread is already in the state map (which would happen if one factoid imports another), and if so, it shouldn't add or remove it again. 

I'm thinking the best way to implement the debugger would be to have a DebuggerSupport class that key points in factoid execution call into, and that class calls Object.wait or waits in a blocking queue if the factoid should be blocked.

It'd also be cool if the debugger could also function as a profiler, and show time spent at certain areas of a factoid and potentially show the steps of running a factoid (loading from db, parsing into an execution tree, running the execution tree).
